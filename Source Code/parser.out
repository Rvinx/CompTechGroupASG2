Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program statement
Rule 2     program -> statement
Rule 3     program -> error
Rule 4     statement -> INTEGER command NEWLINE
Rule 5     statement -> INTEGER error NEWLINE
Rule 6     statement -> NEWLINE
Rule 7     statement -> INTEGER NEWLINE
Rule 8     command -> DATA numlist
Rule 9     command -> DATA error
Rule 10    command -> WRITELN LPAREN wlist RPAREN ending
Rule 11    command -> WRITELN error
Rule 12    command -> WRITELN LPAREN RPAREN ending
Rule 13    command -> WRITE LPAREN wlist RPAREN ending
Rule 14    command -> WRITE error
Rule 15    command -> WRITE LPAREN RPAREN ending
Rule 16    command -> PROGRAM variable ending
Rule 17    command -> VAR varlist COLON variable ending
Rule 18    command -> VAR error
Rule 19    command -> variable COLON variable ending
Rule 20    command -> variable error
Rule 21    command -> variable COLON EQUALS expr SEMI
Rule 22    varlist -> varlist COMMA variable
Rule 23    varlist -> variable
Rule 24    expr -> INTEGER
Rule 25    expr -> FLOAT
Rule 26    expr -> variable
Rule 27    expr -> expr PLUS expr
Rule 28    expr -> expr MINUS expr
Rule 29    expr -> expr TIMES expr
Rule 30    expr -> expr DIVIDE expr
Rule 31    expr -> expr POWER expr
Rule 32    variable -> ID
Rule 33    command -> END DOT
Rule 34    command -> BEGIN
Rule 35    ending -> SEMI
Rule 36    command -> IF LPAREN relexpr RPAREN THEN INTEGER INTEGER
Rule 37    command -> IF LPAREN error RPAREN THEN INTEGER INTEGER
Rule 38    command -> IF LPAREN relexpr RPAREN THEN error
Rule 39    command -> ELSE INTEGER
Rule 40    command -> END ending
Rule 41    command -> END INTEGER
Rule 42    relexpr -> expr LT expr
Rule 43    relexpr -> expr LE expr
Rule 44    relexpr -> expr GT expr
Rule 45    relexpr -> expr GE expr
Rule 46    relexpr -> expr EQUALS expr
Rule 47    relexpr -> expr NE expr
Rule 48    wlist -> wlist COMMA witem
Rule 49    wlist -> witem
Rule 50    witem -> STRING
Rule 51    witem -> expr
Rule 52    numlist -> numlist COMMA number
Rule 53    numlist -> number
Rule 54    number -> INTEGER
Rule 55    number -> FLOAT

Terminals, with rules where they appear

BEGIN                : 34
COLON                : 17 19 21
COMMA                : 22 48 52
DATA                 : 8 9
DIVIDE               : 30
DOT                  : 33
ELSE                 : 39
END                  : 33 40 41
EQUALS               : 21 46
FLOAT                : 25 55
GE                   : 45
GT                   : 44
ID                   : 32
IF                   : 36 37 38
INTEGER              : 4 5 7 24 36 36 37 37 39 41 54
LE                   : 43
LPAREN               : 10 12 13 15 36 37 38
LT                   : 42
MINUS                : 28
NE                   : 47
NEWLINE              : 4 5 6 7
PLUS                 : 27
POWER                : 31
PROGRAM              : 16
RPAREN               : 10 12 13 15 36 37 38
SEMI                 : 21 35
STRING               : 50
THEN                 : 36 37 38
TIMES                : 29
VAR                  : 17 18
WRITE                : 13 14 15
WRITELN              : 10 11 12
error                : 3 5 9 11 14 18 20 37 38

Nonterminals, with rules where they appear

command              : 4
ending               : 10 12 13 15 16 17 19 40
expr                 : 21 27 27 28 28 29 29 30 30 31 31 42 42 43 43 44 44 45 45 46 46 47 47 51
number               : 52 53
numlist              : 8 52
program              : 1 0
relexpr              : 36 38
statement            : 1 2
variable             : 16 17 19 19 20 21 22 23 26
varlist              : 17 22
witem                : 48 49
wlist                : 10 13 48

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program statement
    (2) program -> . statement
    (3) program -> . error
    (4) statement -> . INTEGER command NEWLINE
    (5) statement -> . INTEGER error NEWLINE
    (6) statement -> . NEWLINE
    (7) statement -> . INTEGER NEWLINE

    error           shift and go to state 3
    INTEGER         shift and go to state 4
    NEWLINE         shift and go to state 5

    program                        shift and go to state 1
    statement                      shift and go to state 2

state 1

    (0) S' -> program .
    (1) program -> program . statement
    (4) statement -> . INTEGER command NEWLINE
    (5) statement -> . INTEGER error NEWLINE
    (6) statement -> . NEWLINE
    (7) statement -> . INTEGER NEWLINE

    INTEGER         shift and go to state 4
    NEWLINE         shift and go to state 5

    statement                      shift and go to state 6

state 2

    (2) program -> statement .

    INTEGER         reduce using rule 2 (program -> statement .)
    NEWLINE         reduce using rule 2 (program -> statement .)
    $end            reduce using rule 2 (program -> statement .)


state 3

    (3) program -> error .

    INTEGER         reduce using rule 3 (program -> error .)
    NEWLINE         reduce using rule 3 (program -> error .)
    $end            reduce using rule 3 (program -> error .)


state 4

    (4) statement -> INTEGER . command NEWLINE
    (5) statement -> INTEGER . error NEWLINE
    (7) statement -> INTEGER . NEWLINE
    (8) command -> . DATA numlist
    (9) command -> . DATA error
    (10) command -> . WRITELN LPAREN wlist RPAREN ending
    (11) command -> . WRITELN error
    (12) command -> . WRITELN LPAREN RPAREN ending
    (13) command -> . WRITE LPAREN wlist RPAREN ending
    (14) command -> . WRITE error
    (15) command -> . WRITE LPAREN RPAREN ending
    (16) command -> . PROGRAM variable ending
    (17) command -> . VAR varlist COLON variable ending
    (18) command -> . VAR error
    (19) command -> . variable COLON variable ending
    (20) command -> . variable error
    (21) command -> . variable COLON EQUALS expr SEMI
    (33) command -> . END DOT
    (34) command -> . BEGIN
    (36) command -> . IF LPAREN relexpr RPAREN THEN INTEGER INTEGER
    (37) command -> . IF LPAREN error RPAREN THEN INTEGER INTEGER
    (38) command -> . IF LPAREN relexpr RPAREN THEN error
    (39) command -> . ELSE INTEGER
    (40) command -> . END ending
    (41) command -> . END INTEGER
    (32) variable -> . ID

    error           shift and go to state 9
    NEWLINE         shift and go to state 8
    DATA            shift and go to state 10
    WRITELN         shift and go to state 11
    WRITE           shift and go to state 12
    PROGRAM         shift and go to state 13
    VAR             shift and go to state 15
    END             shift and go to state 16
    BEGIN           shift and go to state 17
    IF              shift and go to state 18
    ELSE            shift and go to state 19
    ID              shift and go to state 20

    command                        shift and go to state 7
    variable                       shift and go to state 14

state 5

    (6) statement -> NEWLINE .

    INTEGER         reduce using rule 6 (statement -> NEWLINE .)
    NEWLINE         reduce using rule 6 (statement -> NEWLINE .)
    $end            reduce using rule 6 (statement -> NEWLINE .)


state 6

    (1) program -> program statement .

    INTEGER         reduce using rule 1 (program -> program statement .)
    NEWLINE         reduce using rule 1 (program -> program statement .)
    $end            reduce using rule 1 (program -> program statement .)


state 7

    (4) statement -> INTEGER command . NEWLINE

    NEWLINE         shift and go to state 21


state 8

    (7) statement -> INTEGER NEWLINE .

    INTEGER         reduce using rule 7 (statement -> INTEGER NEWLINE .)
    NEWLINE         reduce using rule 7 (statement -> INTEGER NEWLINE .)
    $end            reduce using rule 7 (statement -> INTEGER NEWLINE .)


state 9

    (5) statement -> INTEGER error . NEWLINE

    NEWLINE         shift and go to state 22


state 10

    (8) command -> DATA . numlist
    (9) command -> DATA . error
    (52) numlist -> . numlist COMMA number
    (53) numlist -> . number
    (54) number -> . INTEGER
    (55) number -> . FLOAT

    error           shift and go to state 24
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 27

    numlist                        shift and go to state 23
    number                         shift and go to state 25

state 11

    (10) command -> WRITELN . LPAREN wlist RPAREN ending
    (11) command -> WRITELN . error
    (12) command -> WRITELN . LPAREN RPAREN ending

    LPAREN          shift and go to state 28
    error           shift and go to state 29


state 12

    (13) command -> WRITE . LPAREN wlist RPAREN ending
    (14) command -> WRITE . error
    (15) command -> WRITE . LPAREN RPAREN ending

    LPAREN          shift and go to state 30
    error           shift and go to state 31


state 13

    (16) command -> PROGRAM . variable ending
    (32) variable -> . ID

    ID              shift and go to state 20

    variable                       shift and go to state 32

state 14

    (19) command -> variable . COLON variable ending
    (20) command -> variable . error
    (21) command -> variable . COLON EQUALS expr SEMI

    COLON           shift and go to state 33
    error           shift and go to state 34


state 15

    (17) command -> VAR . varlist COLON variable ending
    (18) command -> VAR . error
    (22) varlist -> . varlist COMMA variable
    (23) varlist -> . variable
    (32) variable -> . ID

    error           shift and go to state 37
    ID              shift and go to state 20

    varlist                        shift and go to state 35
    variable                       shift and go to state 36

state 16

    (33) command -> END . DOT
    (40) command -> END . ending
    (41) command -> END . INTEGER
    (35) ending -> . SEMI

    DOT             shift and go to state 38
    INTEGER         shift and go to state 40
    SEMI            shift and go to state 41

    ending                         shift and go to state 39

state 17

    (34) command -> BEGIN .

    NEWLINE         reduce using rule 34 (command -> BEGIN .)


state 18

    (36) command -> IF . LPAREN relexpr RPAREN THEN INTEGER INTEGER
    (37) command -> IF . LPAREN error RPAREN THEN INTEGER INTEGER
    (38) command -> IF . LPAREN relexpr RPAREN THEN error

    LPAREN          shift and go to state 42


state 19

    (39) command -> ELSE . INTEGER

    INTEGER         shift and go to state 43


state 20

    (32) variable -> ID .

    COLON           reduce using rule 32 (variable -> ID .)
    error           reduce using rule 32 (variable -> ID .)
    SEMI            reduce using rule 32 (variable -> ID .)
    COMMA           reduce using rule 32 (variable -> ID .)
    PLUS            reduce using rule 32 (variable -> ID .)
    MINUS           reduce using rule 32 (variable -> ID .)
    TIMES           reduce using rule 32 (variable -> ID .)
    DIVIDE          reduce using rule 32 (variable -> ID .)
    POWER           reduce using rule 32 (variable -> ID .)
    RPAREN          reduce using rule 32 (variable -> ID .)
    LT              reduce using rule 32 (variable -> ID .)
    LE              reduce using rule 32 (variable -> ID .)
    GT              reduce using rule 32 (variable -> ID .)
    GE              reduce using rule 32 (variable -> ID .)
    EQUALS          reduce using rule 32 (variable -> ID .)
    NE              reduce using rule 32 (variable -> ID .)


state 21

    (4) statement -> INTEGER command NEWLINE .

    INTEGER         reduce using rule 4 (statement -> INTEGER command NEWLINE .)
    NEWLINE         reduce using rule 4 (statement -> INTEGER command NEWLINE .)
    $end            reduce using rule 4 (statement -> INTEGER command NEWLINE .)


state 22

    (5) statement -> INTEGER error NEWLINE .

    INTEGER         reduce using rule 5 (statement -> INTEGER error NEWLINE .)
    NEWLINE         reduce using rule 5 (statement -> INTEGER error NEWLINE .)
    $end            reduce using rule 5 (statement -> INTEGER error NEWLINE .)


state 23

    (8) command -> DATA numlist .
    (52) numlist -> numlist . COMMA number

    NEWLINE         reduce using rule 8 (command -> DATA numlist .)
    COMMA           shift and go to state 44


state 24

    (9) command -> DATA error .

    NEWLINE         reduce using rule 9 (command -> DATA error .)


state 25

    (53) numlist -> number .

    COMMA           reduce using rule 53 (numlist -> number .)
    NEWLINE         reduce using rule 53 (numlist -> number .)


state 26

    (54) number -> INTEGER .

    COMMA           reduce using rule 54 (number -> INTEGER .)
    NEWLINE         reduce using rule 54 (number -> INTEGER .)


state 27

    (55) number -> FLOAT .

    COMMA           reduce using rule 55 (number -> FLOAT .)
    NEWLINE         reduce using rule 55 (number -> FLOAT .)


state 28

    (10) command -> WRITELN LPAREN . wlist RPAREN ending
    (12) command -> WRITELN LPAREN . RPAREN ending
    (48) wlist -> . wlist COMMA witem
    (49) wlist -> . witem
    (50) witem -> . STRING
    (51) witem -> . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    RPAREN          shift and go to state 46
    STRING          shift and go to state 48
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    wlist                          shift and go to state 45
    witem                          shift and go to state 47
    expr                           shift and go to state 49
    variable                       shift and go to state 52

state 29

    (11) command -> WRITELN error .

    NEWLINE         reduce using rule 11 (command -> WRITELN error .)


state 30

    (13) command -> WRITE LPAREN . wlist RPAREN ending
    (15) command -> WRITE LPAREN . RPAREN ending
    (48) wlist -> . wlist COMMA witem
    (49) wlist -> . witem
    (50) witem -> . STRING
    (51) witem -> . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    RPAREN          shift and go to state 54
    STRING          shift and go to state 48
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    wlist                          shift and go to state 53
    witem                          shift and go to state 47
    expr                           shift and go to state 49
    variable                       shift and go to state 52

state 31

    (14) command -> WRITE error .

    NEWLINE         reduce using rule 14 (command -> WRITE error .)


state 32

    (16) command -> PROGRAM variable . ending
    (35) ending -> . SEMI

    SEMI            shift and go to state 41

    ending                         shift and go to state 55

state 33

    (19) command -> variable COLON . variable ending
    (21) command -> variable COLON . EQUALS expr SEMI
    (32) variable -> . ID

    EQUALS          shift and go to state 57
    ID              shift and go to state 20

    variable                       shift and go to state 56

state 34

    (20) command -> variable error .

    NEWLINE         reduce using rule 20 (command -> variable error .)


state 35

    (17) command -> VAR varlist . COLON variable ending
    (22) varlist -> varlist . COMMA variable

    COLON           shift and go to state 58
    COMMA           shift and go to state 59


state 36

    (23) varlist -> variable .

    COLON           reduce using rule 23 (varlist -> variable .)
    COMMA           reduce using rule 23 (varlist -> variable .)


state 37

    (18) command -> VAR error .

    NEWLINE         reduce using rule 18 (command -> VAR error .)


state 38

    (33) command -> END DOT .

    NEWLINE         reduce using rule 33 (command -> END DOT .)


state 39

    (40) command -> END ending .

    NEWLINE         reduce using rule 40 (command -> END ending .)


state 40

    (41) command -> END INTEGER .

    NEWLINE         reduce using rule 41 (command -> END INTEGER .)


state 41

    (35) ending -> SEMI .

    NEWLINE         reduce using rule 35 (ending -> SEMI .)


state 42

    (36) command -> IF LPAREN . relexpr RPAREN THEN INTEGER INTEGER
    (37) command -> IF LPAREN . error RPAREN THEN INTEGER INTEGER
    (38) command -> IF LPAREN . relexpr RPAREN THEN error
    (42) relexpr -> . expr LT expr
    (43) relexpr -> . expr LE expr
    (44) relexpr -> . expr GT expr
    (45) relexpr -> . expr GE expr
    (46) relexpr -> . expr EQUALS expr
    (47) relexpr -> . expr NE expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    error           shift and go to state 61
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    relexpr                        shift and go to state 60
    expr                           shift and go to state 62
    variable                       shift and go to state 52

state 43

    (39) command -> ELSE INTEGER .

    NEWLINE         reduce using rule 39 (command -> ELSE INTEGER .)


state 44

    (52) numlist -> numlist COMMA . number
    (54) number -> . INTEGER
    (55) number -> . FLOAT

    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 27

    number                         shift and go to state 63

state 45

    (10) command -> WRITELN LPAREN wlist . RPAREN ending
    (48) wlist -> wlist . COMMA witem

    RPAREN          shift and go to state 64
    COMMA           shift and go to state 65


state 46

    (12) command -> WRITELN LPAREN RPAREN . ending
    (35) ending -> . SEMI

    SEMI            shift and go to state 41

    ending                         shift and go to state 66

state 47

    (49) wlist -> witem .

    RPAREN          reduce using rule 49 (wlist -> witem .)
    COMMA           reduce using rule 49 (wlist -> witem .)


state 48

    (50) witem -> STRING .

    RPAREN          reduce using rule 50 (witem -> STRING .)
    COMMA           reduce using rule 50 (witem -> STRING .)


state 49

    (51) witem -> expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    RPAREN          reduce using rule 51 (witem -> expr .)
    COMMA           reduce using rule 51 (witem -> expr .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 50

    (24) expr -> INTEGER .

    PLUS            reduce using rule 24 (expr -> INTEGER .)
    MINUS           reduce using rule 24 (expr -> INTEGER .)
    TIMES           reduce using rule 24 (expr -> INTEGER .)
    DIVIDE          reduce using rule 24 (expr -> INTEGER .)
    POWER           reduce using rule 24 (expr -> INTEGER .)
    RPAREN          reduce using rule 24 (expr -> INTEGER .)
    COMMA           reduce using rule 24 (expr -> INTEGER .)
    LT              reduce using rule 24 (expr -> INTEGER .)
    LE              reduce using rule 24 (expr -> INTEGER .)
    GT              reduce using rule 24 (expr -> INTEGER .)
    GE              reduce using rule 24 (expr -> INTEGER .)
    EQUALS          reduce using rule 24 (expr -> INTEGER .)
    NE              reduce using rule 24 (expr -> INTEGER .)
    SEMI            reduce using rule 24 (expr -> INTEGER .)


state 51

    (25) expr -> FLOAT .

    PLUS            reduce using rule 25 (expr -> FLOAT .)
    MINUS           reduce using rule 25 (expr -> FLOAT .)
    TIMES           reduce using rule 25 (expr -> FLOAT .)
    DIVIDE          reduce using rule 25 (expr -> FLOAT .)
    POWER           reduce using rule 25 (expr -> FLOAT .)
    RPAREN          reduce using rule 25 (expr -> FLOAT .)
    COMMA           reduce using rule 25 (expr -> FLOAT .)
    LT              reduce using rule 25 (expr -> FLOAT .)
    LE              reduce using rule 25 (expr -> FLOAT .)
    GT              reduce using rule 25 (expr -> FLOAT .)
    GE              reduce using rule 25 (expr -> FLOAT .)
    EQUALS          reduce using rule 25 (expr -> FLOAT .)
    NE              reduce using rule 25 (expr -> FLOAT .)
    SEMI            reduce using rule 25 (expr -> FLOAT .)


state 52

    (26) expr -> variable .

    PLUS            reduce using rule 26 (expr -> variable .)
    MINUS           reduce using rule 26 (expr -> variable .)
    TIMES           reduce using rule 26 (expr -> variable .)
    DIVIDE          reduce using rule 26 (expr -> variable .)
    POWER           reduce using rule 26 (expr -> variable .)
    RPAREN          reduce using rule 26 (expr -> variable .)
    COMMA           reduce using rule 26 (expr -> variable .)
    LT              reduce using rule 26 (expr -> variable .)
    LE              reduce using rule 26 (expr -> variable .)
    GT              reduce using rule 26 (expr -> variable .)
    GE              reduce using rule 26 (expr -> variable .)
    EQUALS          reduce using rule 26 (expr -> variable .)
    NE              reduce using rule 26 (expr -> variable .)
    SEMI            reduce using rule 26 (expr -> variable .)


state 53

    (13) command -> WRITE LPAREN wlist . RPAREN ending
    (48) wlist -> wlist . COMMA witem

    RPAREN          shift and go to state 72
    COMMA           shift and go to state 65


state 54

    (15) command -> WRITE LPAREN RPAREN . ending
    (35) ending -> . SEMI

    SEMI            shift and go to state 41

    ending                         shift and go to state 73

state 55

    (16) command -> PROGRAM variable ending .

    NEWLINE         reduce using rule 16 (command -> PROGRAM variable ending .)


state 56

    (19) command -> variable COLON variable . ending
    (35) ending -> . SEMI

    SEMI            shift and go to state 41

    ending                         shift and go to state 74

state 57

    (21) command -> variable COLON EQUALS . expr SEMI
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    variable                       shift and go to state 52
    expr                           shift and go to state 75

state 58

    (17) command -> VAR varlist COLON . variable ending
    (32) variable -> . ID

    ID              shift and go to state 20

    variable                       shift and go to state 76

state 59

    (22) varlist -> varlist COMMA . variable
    (32) variable -> . ID

    ID              shift and go to state 20

    variable                       shift and go to state 77

state 60

    (36) command -> IF LPAREN relexpr . RPAREN THEN INTEGER INTEGER
    (38) command -> IF LPAREN relexpr . RPAREN THEN error

    RPAREN          shift and go to state 78


state 61

    (37) command -> IF LPAREN error . RPAREN THEN INTEGER INTEGER

    RPAREN          shift and go to state 79


state 62

    (42) relexpr -> expr . LT expr
    (43) relexpr -> expr . LE expr
    (44) relexpr -> expr . GT expr
    (45) relexpr -> expr . GE expr
    (46) relexpr -> expr . EQUALS expr
    (47) relexpr -> expr . NE expr
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    LT              shift and go to state 80
    LE              shift and go to state 81
    GT              shift and go to state 82
    GE              shift and go to state 83
    EQUALS          shift and go to state 84
    NE              shift and go to state 85
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 63

    (52) numlist -> numlist COMMA number .

    COMMA           reduce using rule 52 (numlist -> numlist COMMA number .)
    NEWLINE         reduce using rule 52 (numlist -> numlist COMMA number .)


state 64

    (10) command -> WRITELN LPAREN wlist RPAREN . ending
    (35) ending -> . SEMI

    SEMI            shift and go to state 41

    ending                         shift and go to state 86

state 65

    (48) wlist -> wlist COMMA . witem
    (50) witem -> . STRING
    (51) witem -> . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    STRING          shift and go to state 48
    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    witem                          shift and go to state 87
    expr                           shift and go to state 49
    variable                       shift and go to state 52

state 66

    (12) command -> WRITELN LPAREN RPAREN ending .

    NEWLINE         reduce using rule 12 (command -> WRITELN LPAREN RPAREN ending .)


state 67

    (27) expr -> expr PLUS . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 88
    variable                       shift and go to state 52

state 68

    (28) expr -> expr MINUS . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 89
    variable                       shift and go to state 52

state 69

    (29) expr -> expr TIMES . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 90
    variable                       shift and go to state 52

state 70

    (30) expr -> expr DIVIDE . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 91
    variable                       shift and go to state 52

state 71

    (31) expr -> expr POWER . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 92
    variable                       shift and go to state 52

state 72

    (13) command -> WRITE LPAREN wlist RPAREN . ending
    (35) ending -> . SEMI

    SEMI            shift and go to state 41

    ending                         shift and go to state 93

state 73

    (15) command -> WRITE LPAREN RPAREN ending .

    NEWLINE         reduce using rule 15 (command -> WRITE LPAREN RPAREN ending .)


state 74

    (19) command -> variable COLON variable ending .

    NEWLINE         reduce using rule 19 (command -> variable COLON variable ending .)


state 75

    (21) command -> variable COLON EQUALS expr . SEMI
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    SEMI            shift and go to state 94
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 76

    (17) command -> VAR varlist COLON variable . ending
    (35) ending -> . SEMI

    SEMI            shift and go to state 41

    ending                         shift and go to state 95

state 77

    (22) varlist -> varlist COMMA variable .

    COLON           reduce using rule 22 (varlist -> varlist COMMA variable .)
    COMMA           reduce using rule 22 (varlist -> varlist COMMA variable .)


state 78

    (36) command -> IF LPAREN relexpr RPAREN . THEN INTEGER INTEGER
    (38) command -> IF LPAREN relexpr RPAREN . THEN error

    THEN            shift and go to state 96


state 79

    (37) command -> IF LPAREN error RPAREN . THEN INTEGER INTEGER

    THEN            shift and go to state 97


state 80

    (42) relexpr -> expr LT . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 98
    variable                       shift and go to state 52

state 81

    (43) relexpr -> expr LE . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 99
    variable                       shift and go to state 52

state 82

    (44) relexpr -> expr GT . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 100
    variable                       shift and go to state 52

state 83

    (45) relexpr -> expr GE . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 101
    variable                       shift and go to state 52

state 84

    (46) relexpr -> expr EQUALS . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 102
    variable                       shift and go to state 52

state 85

    (47) relexpr -> expr NE . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) variable -> . ID

    INTEGER         shift and go to state 50
    FLOAT           shift and go to state 51
    ID              shift and go to state 20

    expr                           shift and go to state 103
    variable                       shift and go to state 52

state 86

    (10) command -> WRITELN LPAREN wlist RPAREN ending .

    NEWLINE         reduce using rule 10 (command -> WRITELN LPAREN wlist RPAREN ending .)


state 87

    (48) wlist -> wlist COMMA witem .

    RPAREN          reduce using rule 48 (wlist -> wlist COMMA witem .)
    COMMA           reduce using rule 48 (wlist -> wlist COMMA witem .)


state 88

    (27) expr -> expr PLUS expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    PLUS            reduce using rule 27 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 27 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 27 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 27 (expr -> expr PLUS expr .)
    LT              reduce using rule 27 (expr -> expr PLUS expr .)
    LE              reduce using rule 27 (expr -> expr PLUS expr .)
    GT              reduce using rule 27 (expr -> expr PLUS expr .)
    GE              reduce using rule 27 (expr -> expr PLUS expr .)
    EQUALS          reduce using rule 27 (expr -> expr PLUS expr .)
    NE              reduce using rule 27 (expr -> expr PLUS expr .)
    SEMI            reduce using rule 27 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71

  ! TIMES           [ reduce using rule 27 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 27 (expr -> expr PLUS expr .) ]
  ! POWER           [ reduce using rule 27 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]


state 89

    (28) expr -> expr MINUS expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    PLUS            reduce using rule 28 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 28 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 28 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 28 (expr -> expr MINUS expr .)
    LT              reduce using rule 28 (expr -> expr MINUS expr .)
    LE              reduce using rule 28 (expr -> expr MINUS expr .)
    GT              reduce using rule 28 (expr -> expr MINUS expr .)
    GE              reduce using rule 28 (expr -> expr MINUS expr .)
    EQUALS          reduce using rule 28 (expr -> expr MINUS expr .)
    NE              reduce using rule 28 (expr -> expr MINUS expr .)
    SEMI            reduce using rule 28 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71

  ! TIMES           [ reduce using rule 28 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 28 (expr -> expr MINUS expr .) ]
  ! POWER           [ reduce using rule 28 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]


state 90

    (29) expr -> expr TIMES expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    PLUS            reduce using rule 29 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 29 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 29 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 29 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 29 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 29 (expr -> expr TIMES expr .)
    LT              reduce using rule 29 (expr -> expr TIMES expr .)
    LE              reduce using rule 29 (expr -> expr TIMES expr .)
    GT              reduce using rule 29 (expr -> expr TIMES expr .)
    GE              reduce using rule 29 (expr -> expr TIMES expr .)
    EQUALS          reduce using rule 29 (expr -> expr TIMES expr .)
    NE              reduce using rule 29 (expr -> expr TIMES expr .)
    SEMI            reduce using rule 29 (expr -> expr TIMES expr .)
    POWER           shift and go to state 71

  ! POWER           [ reduce using rule 29 (expr -> expr TIMES expr .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 70 ]


state 91

    (30) expr -> expr DIVIDE expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    PLUS            reduce using rule 30 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 30 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 30 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 30 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 30 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 30 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 30 (expr -> expr DIVIDE expr .)
    LE              reduce using rule 30 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 30 (expr -> expr DIVIDE expr .)
    GE              reduce using rule 30 (expr -> expr DIVIDE expr .)
    EQUALS          reduce using rule 30 (expr -> expr DIVIDE expr .)
    NE              reduce using rule 30 (expr -> expr DIVIDE expr .)
    SEMI            reduce using rule 30 (expr -> expr DIVIDE expr .)
    POWER           shift and go to state 71

  ! POWER           [ reduce using rule 30 (expr -> expr DIVIDE expr .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 70 ]


state 92

    (31) expr -> expr POWER expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    PLUS            reduce using rule 31 (expr -> expr POWER expr .)
    MINUS           reduce using rule 31 (expr -> expr POWER expr .)
    TIMES           reduce using rule 31 (expr -> expr POWER expr .)
    DIVIDE          reduce using rule 31 (expr -> expr POWER expr .)
    POWER           reduce using rule 31 (expr -> expr POWER expr .)
    RPAREN          reduce using rule 31 (expr -> expr POWER expr .)
    COMMA           reduce using rule 31 (expr -> expr POWER expr .)
    LT              reduce using rule 31 (expr -> expr POWER expr .)
    LE              reduce using rule 31 (expr -> expr POWER expr .)
    GT              reduce using rule 31 (expr -> expr POWER expr .)
    GE              reduce using rule 31 (expr -> expr POWER expr .)
    EQUALS          reduce using rule 31 (expr -> expr POWER expr .)
    NE              reduce using rule 31 (expr -> expr POWER expr .)
    SEMI            reduce using rule 31 (expr -> expr POWER expr .)

  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 70 ]
  ! POWER           [ shift and go to state 71 ]


state 93

    (13) command -> WRITE LPAREN wlist RPAREN ending .

    NEWLINE         reduce using rule 13 (command -> WRITE LPAREN wlist RPAREN ending .)


state 94

    (21) command -> variable COLON EQUALS expr SEMI .

    NEWLINE         reduce using rule 21 (command -> variable COLON EQUALS expr SEMI .)


state 95

    (17) command -> VAR varlist COLON variable ending .

    NEWLINE         reduce using rule 17 (command -> VAR varlist COLON variable ending .)


state 96

    (36) command -> IF LPAREN relexpr RPAREN THEN . INTEGER INTEGER
    (38) command -> IF LPAREN relexpr RPAREN THEN . error

    INTEGER         shift and go to state 104
    error           shift and go to state 105


state 97

    (37) command -> IF LPAREN error RPAREN THEN . INTEGER INTEGER

    INTEGER         shift and go to state 106


state 98

    (42) relexpr -> expr LT expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    RPAREN          reduce using rule 42 (relexpr -> expr LT expr .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 99

    (43) relexpr -> expr LE expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    RPAREN          reduce using rule 43 (relexpr -> expr LE expr .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 100

    (44) relexpr -> expr GT expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    RPAREN          reduce using rule 44 (relexpr -> expr GT expr .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 101

    (45) relexpr -> expr GE expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    RPAREN          reduce using rule 45 (relexpr -> expr GE expr .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 102

    (46) relexpr -> expr EQUALS expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    RPAREN          reduce using rule 46 (relexpr -> expr EQUALS expr .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 103

    (47) relexpr -> expr NE expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr

    RPAREN          reduce using rule 47 (relexpr -> expr NE expr .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 104

    (36) command -> IF LPAREN relexpr RPAREN THEN INTEGER . INTEGER

    INTEGER         shift and go to state 107


state 105

    (38) command -> IF LPAREN relexpr RPAREN THEN error .

    NEWLINE         reduce using rule 38 (command -> IF LPAREN relexpr RPAREN THEN error .)


state 106

    (37) command -> IF LPAREN error RPAREN THEN INTEGER . INTEGER

    INTEGER         shift and go to state 108


state 107

    (36) command -> IF LPAREN relexpr RPAREN THEN INTEGER INTEGER .

    NEWLINE         reduce using rule 36 (command -> IF LPAREN relexpr RPAREN THEN INTEGER INTEGER .)


state 108

    (37) command -> IF LPAREN error RPAREN THEN INTEGER INTEGER .

    NEWLINE         reduce using rule 37 (command -> IF LPAREN error RPAREN THEN INTEGER INTEGER .)

