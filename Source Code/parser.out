Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program statement
Rule 2     program -> statement
Rule 3     program -> error
Rule 4     statement -> INTEGER command NEWLINE
Rule 5     statement -> INTEGER error NEWLINE
Rule 6     statement -> NEWLINE
Rule 7     statement -> INTEGER NEWLINE
Rule 8     command -> DATA numlist
Rule 9     command -> DATA error
Rule 10    command -> WRITELN LPAREN wlist RPAREN ending
Rule 11    command -> WRITELN error
Rule 12    command -> WRITELN ending
Rule 13    command -> WRITE LPAREN wlist RPAREN ending
Rule 14    command -> WRITE error
Rule 15    command -> WRITE LPAREN RPAREN ending
Rule 16    command -> PROGRAM variable ending
Rule 17    command -> VAR varlist COLON variable ending
Rule 18    command -> VAR error
Rule 19    command -> variable COLON variable ending
Rule 20    command -> variable error
Rule 21    command -> variable COLON EQUALS expr SEMI
Rule 22    varlist -> varlist COMMA variable
Rule 23    varlist -> variable
Rule 24    expr -> INTEGER
Rule 25    expr -> FLOAT
Rule 26    expr -> variable
Rule 27    expr -> expr PLUS expr
Rule 28    expr -> expr MINUS expr
Rule 29    expr -> expr TIMES expr
Rule 30    expr -> expr DIVIDE expr
Rule 31    expr -> expr POWER expr
Rule 32    expr -> expr MOD expr
Rule 33    variable -> ID
Rule 34    command -> END DOT
Rule 35    command -> BEGIN
Rule 36    ending -> SEMI
Rule 37    command -> IF LPAREN relexpr RPAREN THEN INTEGER INTEGER
Rule 38    command -> IF LPAREN error RPAREN THEN INTEGER INTEGER
Rule 39    command -> IF LPAREN relexpr RPAREN THEN error
Rule 40    command -> ELSE
Rule 41    command -> END ending
Rule 42    command -> END ending INTEGER INTEGER
Rule 43    command -> END INTEGER
Rule 44    relexpr -> expr LT expr
Rule 45    relexpr -> expr LE expr
Rule 46    relexpr -> expr GT expr
Rule 47    relexpr -> expr GE expr
Rule 48    relexpr -> expr EQUALS expr
Rule 49    relexpr -> expr NE expr
Rule 50    command -> FOR variable COLON EQUALS expr TO expr DO INTEGER INTEGER
Rule 51    wlist -> wlist COMMA witem
Rule 52    wlist -> witem
Rule 53    witem -> STRING
Rule 54    witem -> expr
Rule 55    numlist -> numlist COMMA number
Rule 56    numlist -> number
Rule 57    number -> INTEGER
Rule 58    number -> FLOAT

Terminals, with rules where they appear

BEGIN                : 35
COLON                : 17 19 21 50
COMMA                : 22 51 55
DATA                 : 8 9
DIVIDE               : 30
DO                   : 50
DOT                  : 34
ELSE                 : 40
END                  : 34 41 42 43
EQUALS               : 21 48 50
FLOAT                : 25 58
FOR                  : 50
GE                   : 47
GT                   : 46
ID                   : 33
IF                   : 37 38 39
INTEGER              : 4 5 7 24 37 37 38 38 42 42 43 50 50 57
LE                   : 45
LPAREN               : 10 13 15 37 38 39
LT                   : 44
MINUS                : 28
MOD                  : 32
NE                   : 49
NEWLINE              : 4 5 6 7
PLUS                 : 27
POWER                : 31
PROGRAM              : 16
RPAREN               : 10 13 15 37 38 39
SEMI                 : 21 36
STRING               : 53
THEN                 : 37 38 39
TIMES                : 29
TO                   : 50
VAR                  : 17 18
WRITE                : 13 14 15
WRITELN              : 10 11 12
error                : 3 5 9 11 14 18 20 38 39

Nonterminals, with rules where they appear

command              : 4
ending               : 10 12 13 15 16 17 19 41 42
expr                 : 21 27 27 28 28 29 29 30 30 31 31 32 32 44 44 45 45 46 46 47 47 48 48 49 49 50 50 54
number               : 55 56
numlist              : 8 55
program              : 1 0
relexpr              : 37 39
statement            : 1 2
variable             : 16 17 19 19 20 21 22 23 26 50
varlist              : 17 22
witem                : 51 52
wlist                : 10 13 51

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program statement
    (2) program -> . statement
    (3) program -> . error
    (4) statement -> . INTEGER command NEWLINE
    (5) statement -> . INTEGER error NEWLINE
    (6) statement -> . NEWLINE
    (7) statement -> . INTEGER NEWLINE

    error           shift and go to state 3
    INTEGER         shift and go to state 4
    NEWLINE         shift and go to state 5

    program                        shift and go to state 1
    statement                      shift and go to state 2

state 1

    (0) S' -> program .
    (1) program -> program . statement
    (4) statement -> . INTEGER command NEWLINE
    (5) statement -> . INTEGER error NEWLINE
    (6) statement -> . NEWLINE
    (7) statement -> . INTEGER NEWLINE

    INTEGER         shift and go to state 4
    NEWLINE         shift and go to state 5

    statement                      shift and go to state 6

state 2

    (2) program -> statement .

    INTEGER         reduce using rule 2 (program -> statement .)
    NEWLINE         reduce using rule 2 (program -> statement .)
    $end            reduce using rule 2 (program -> statement .)


state 3

    (3) program -> error .

    INTEGER         reduce using rule 3 (program -> error .)
    NEWLINE         reduce using rule 3 (program -> error .)
    $end            reduce using rule 3 (program -> error .)


state 4

    (4) statement -> INTEGER . command NEWLINE
    (5) statement -> INTEGER . error NEWLINE
    (7) statement -> INTEGER . NEWLINE
    (8) command -> . DATA numlist
    (9) command -> . DATA error
    (10) command -> . WRITELN LPAREN wlist RPAREN ending
    (11) command -> . WRITELN error
    (12) command -> . WRITELN ending
    (13) command -> . WRITE LPAREN wlist RPAREN ending
    (14) command -> . WRITE error
    (15) command -> . WRITE LPAREN RPAREN ending
    (16) command -> . PROGRAM variable ending
    (17) command -> . VAR varlist COLON variable ending
    (18) command -> . VAR error
    (19) command -> . variable COLON variable ending
    (20) command -> . variable error
    (21) command -> . variable COLON EQUALS expr SEMI
    (34) command -> . END DOT
    (35) command -> . BEGIN
    (37) command -> . IF LPAREN relexpr RPAREN THEN INTEGER INTEGER
    (38) command -> . IF LPAREN error RPAREN THEN INTEGER INTEGER
    (39) command -> . IF LPAREN relexpr RPAREN THEN error
    (40) command -> . ELSE
    (41) command -> . END ending
    (42) command -> . END ending INTEGER INTEGER
    (43) command -> . END INTEGER
    (50) command -> . FOR variable COLON EQUALS expr TO expr DO INTEGER INTEGER
    (33) variable -> . ID

    error           shift and go to state 9
    NEWLINE         shift and go to state 8
    DATA            shift and go to state 10
    WRITELN         shift and go to state 11
    WRITE           shift and go to state 12
    PROGRAM         shift and go to state 13
    VAR             shift and go to state 15
    END             shift and go to state 16
    BEGIN           shift and go to state 17
    IF              shift and go to state 18
    ELSE            shift and go to state 19
    FOR             shift and go to state 20
    ID              shift and go to state 21

    command                        shift and go to state 7
    variable                       shift and go to state 14

state 5

    (6) statement -> NEWLINE .

    INTEGER         reduce using rule 6 (statement -> NEWLINE .)
    NEWLINE         reduce using rule 6 (statement -> NEWLINE .)
    $end            reduce using rule 6 (statement -> NEWLINE .)


state 6

    (1) program -> program statement .

    INTEGER         reduce using rule 1 (program -> program statement .)
    NEWLINE         reduce using rule 1 (program -> program statement .)
    $end            reduce using rule 1 (program -> program statement .)


state 7

    (4) statement -> INTEGER command . NEWLINE

    NEWLINE         shift and go to state 22


state 8

    (7) statement -> INTEGER NEWLINE .

    INTEGER         reduce using rule 7 (statement -> INTEGER NEWLINE .)
    NEWLINE         reduce using rule 7 (statement -> INTEGER NEWLINE .)
    $end            reduce using rule 7 (statement -> INTEGER NEWLINE .)


state 9

    (5) statement -> INTEGER error . NEWLINE

    NEWLINE         shift and go to state 23


state 10

    (8) command -> DATA . numlist
    (9) command -> DATA . error
    (55) numlist -> . numlist COMMA number
    (56) numlist -> . number
    (57) number -> . INTEGER
    (58) number -> . FLOAT

    error           shift and go to state 25
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 28

    numlist                        shift and go to state 24
    number                         shift and go to state 26

state 11

    (10) command -> WRITELN . LPAREN wlist RPAREN ending
    (11) command -> WRITELN . error
    (12) command -> WRITELN . ending
    (36) ending -> . SEMI

    LPAREN          shift and go to state 29
    error           shift and go to state 31
    SEMI            shift and go to state 32

    ending                         shift and go to state 30

state 12

    (13) command -> WRITE . LPAREN wlist RPAREN ending
    (14) command -> WRITE . error
    (15) command -> WRITE . LPAREN RPAREN ending

    LPAREN          shift and go to state 33
    error           shift and go to state 34


state 13

    (16) command -> PROGRAM . variable ending
    (33) variable -> . ID

    ID              shift and go to state 21

    variable                       shift and go to state 35

state 14

    (19) command -> variable . COLON variable ending
    (20) command -> variable . error
    (21) command -> variable . COLON EQUALS expr SEMI

    COLON           shift and go to state 36
    error           shift and go to state 37


state 15

    (17) command -> VAR . varlist COLON variable ending
    (18) command -> VAR . error
    (22) varlist -> . varlist COMMA variable
    (23) varlist -> . variable
    (33) variable -> . ID

    error           shift and go to state 40
    ID              shift and go to state 21

    varlist                        shift and go to state 38
    variable                       shift and go to state 39

state 16

    (34) command -> END . DOT
    (41) command -> END . ending
    (42) command -> END . ending INTEGER INTEGER
    (43) command -> END . INTEGER
    (36) ending -> . SEMI

    DOT             shift and go to state 41
    INTEGER         shift and go to state 43
    SEMI            shift and go to state 32

    ending                         shift and go to state 42

state 17

    (35) command -> BEGIN .

    NEWLINE         reduce using rule 35 (command -> BEGIN .)


state 18

    (37) command -> IF . LPAREN relexpr RPAREN THEN INTEGER INTEGER
    (38) command -> IF . LPAREN error RPAREN THEN INTEGER INTEGER
    (39) command -> IF . LPAREN relexpr RPAREN THEN error

    LPAREN          shift and go to state 44


state 19

    (40) command -> ELSE .

    NEWLINE         reduce using rule 40 (command -> ELSE .)


state 20

    (50) command -> FOR . variable COLON EQUALS expr TO expr DO INTEGER INTEGER
    (33) variable -> . ID

    ID              shift and go to state 21

    variable                       shift and go to state 45

state 21

    (33) variable -> ID .

    COLON           reduce using rule 33 (variable -> ID .)
    error           reduce using rule 33 (variable -> ID .)
    SEMI            reduce using rule 33 (variable -> ID .)
    COMMA           reduce using rule 33 (variable -> ID .)
    PLUS            reduce using rule 33 (variable -> ID .)
    MINUS           reduce using rule 33 (variable -> ID .)
    TIMES           reduce using rule 33 (variable -> ID .)
    DIVIDE          reduce using rule 33 (variable -> ID .)
    POWER           reduce using rule 33 (variable -> ID .)
    MOD             reduce using rule 33 (variable -> ID .)
    RPAREN          reduce using rule 33 (variable -> ID .)
    LT              reduce using rule 33 (variable -> ID .)
    LE              reduce using rule 33 (variable -> ID .)
    GT              reduce using rule 33 (variable -> ID .)
    GE              reduce using rule 33 (variable -> ID .)
    EQUALS          reduce using rule 33 (variable -> ID .)
    NE              reduce using rule 33 (variable -> ID .)
    TO              reduce using rule 33 (variable -> ID .)
    DO              reduce using rule 33 (variable -> ID .)


state 22

    (4) statement -> INTEGER command NEWLINE .

    INTEGER         reduce using rule 4 (statement -> INTEGER command NEWLINE .)
    NEWLINE         reduce using rule 4 (statement -> INTEGER command NEWLINE .)
    $end            reduce using rule 4 (statement -> INTEGER command NEWLINE .)


state 23

    (5) statement -> INTEGER error NEWLINE .

    INTEGER         reduce using rule 5 (statement -> INTEGER error NEWLINE .)
    NEWLINE         reduce using rule 5 (statement -> INTEGER error NEWLINE .)
    $end            reduce using rule 5 (statement -> INTEGER error NEWLINE .)


state 24

    (8) command -> DATA numlist .
    (55) numlist -> numlist . COMMA number

    NEWLINE         reduce using rule 8 (command -> DATA numlist .)
    COMMA           shift and go to state 46


state 25

    (9) command -> DATA error .

    NEWLINE         reduce using rule 9 (command -> DATA error .)


state 26

    (56) numlist -> number .

    COMMA           reduce using rule 56 (numlist -> number .)
    NEWLINE         reduce using rule 56 (numlist -> number .)


state 27

    (57) number -> INTEGER .

    COMMA           reduce using rule 57 (number -> INTEGER .)
    NEWLINE         reduce using rule 57 (number -> INTEGER .)


state 28

    (58) number -> FLOAT .

    COMMA           reduce using rule 58 (number -> FLOAT .)
    NEWLINE         reduce using rule 58 (number -> FLOAT .)


state 29

    (10) command -> WRITELN LPAREN . wlist RPAREN ending
    (51) wlist -> . wlist COMMA witem
    (52) wlist -> . witem
    (53) witem -> . STRING
    (54) witem -> . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    STRING          shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    wlist                          shift and go to state 47
    witem                          shift and go to state 48
    expr                           shift and go to state 50
    variable                       shift and go to state 53

state 30

    (12) command -> WRITELN ending .

    NEWLINE         reduce using rule 12 (command -> WRITELN ending .)


state 31

    (11) command -> WRITELN error .

    NEWLINE         reduce using rule 11 (command -> WRITELN error .)


state 32

    (36) ending -> SEMI .

    NEWLINE         reduce using rule 36 (ending -> SEMI .)
    INTEGER         reduce using rule 36 (ending -> SEMI .)


state 33

    (13) command -> WRITE LPAREN . wlist RPAREN ending
    (15) command -> WRITE LPAREN . RPAREN ending
    (51) wlist -> . wlist COMMA witem
    (52) wlist -> . witem
    (53) witem -> . STRING
    (54) witem -> . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    RPAREN          shift and go to state 55
    STRING          shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    wlist                          shift and go to state 54
    witem                          shift and go to state 48
    expr                           shift and go to state 50
    variable                       shift and go to state 53

state 34

    (14) command -> WRITE error .

    NEWLINE         reduce using rule 14 (command -> WRITE error .)


state 35

    (16) command -> PROGRAM variable . ending
    (36) ending -> . SEMI

    SEMI            shift and go to state 32

    ending                         shift and go to state 56

state 36

    (19) command -> variable COLON . variable ending
    (21) command -> variable COLON . EQUALS expr SEMI
    (33) variable -> . ID

    EQUALS          shift and go to state 58
    ID              shift and go to state 21

    variable                       shift and go to state 57

state 37

    (20) command -> variable error .

    NEWLINE         reduce using rule 20 (command -> variable error .)


state 38

    (17) command -> VAR varlist . COLON variable ending
    (22) varlist -> varlist . COMMA variable

    COLON           shift and go to state 59
    COMMA           shift and go to state 60


state 39

    (23) varlist -> variable .

    COLON           reduce using rule 23 (varlist -> variable .)
    COMMA           reduce using rule 23 (varlist -> variable .)


state 40

    (18) command -> VAR error .

    NEWLINE         reduce using rule 18 (command -> VAR error .)


state 41

    (34) command -> END DOT .

    NEWLINE         reduce using rule 34 (command -> END DOT .)


state 42

    (41) command -> END ending .
    (42) command -> END ending . INTEGER INTEGER

    NEWLINE         reduce using rule 41 (command -> END ending .)
    INTEGER         shift and go to state 61


state 43

    (43) command -> END INTEGER .

    NEWLINE         reduce using rule 43 (command -> END INTEGER .)


state 44

    (37) command -> IF LPAREN . relexpr RPAREN THEN INTEGER INTEGER
    (38) command -> IF LPAREN . error RPAREN THEN INTEGER INTEGER
    (39) command -> IF LPAREN . relexpr RPAREN THEN error
    (44) relexpr -> . expr LT expr
    (45) relexpr -> . expr LE expr
    (46) relexpr -> . expr GT expr
    (47) relexpr -> . expr GE expr
    (48) relexpr -> . expr EQUALS expr
    (49) relexpr -> . expr NE expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    error           shift and go to state 63
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    relexpr                        shift and go to state 62
    expr                           shift and go to state 64
    variable                       shift and go to state 53

state 45

    (50) command -> FOR variable . COLON EQUALS expr TO expr DO INTEGER INTEGER

    COLON           shift and go to state 65


state 46

    (55) numlist -> numlist COMMA . number
    (57) number -> . INTEGER
    (58) number -> . FLOAT

    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 28

    number                         shift and go to state 66

state 47

    (10) command -> WRITELN LPAREN wlist . RPAREN ending
    (51) wlist -> wlist . COMMA witem

    RPAREN          shift and go to state 67
    COMMA           shift and go to state 68


state 48

    (52) wlist -> witem .

    RPAREN          reduce using rule 52 (wlist -> witem .)
    COMMA           reduce using rule 52 (wlist -> witem .)


state 49

    (53) witem -> STRING .

    RPAREN          reduce using rule 53 (witem -> STRING .)
    COMMA           reduce using rule 53 (witem -> STRING .)


state 50

    (54) witem -> expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    RPAREN          reduce using rule 54 (witem -> expr .)
    COMMA           reduce using rule 54 (witem -> expr .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 51

    (24) expr -> INTEGER .

    PLUS            reduce using rule 24 (expr -> INTEGER .)
    MINUS           reduce using rule 24 (expr -> INTEGER .)
    TIMES           reduce using rule 24 (expr -> INTEGER .)
    DIVIDE          reduce using rule 24 (expr -> INTEGER .)
    POWER           reduce using rule 24 (expr -> INTEGER .)
    MOD             reduce using rule 24 (expr -> INTEGER .)
    RPAREN          reduce using rule 24 (expr -> INTEGER .)
    COMMA           reduce using rule 24 (expr -> INTEGER .)
    LT              reduce using rule 24 (expr -> INTEGER .)
    LE              reduce using rule 24 (expr -> INTEGER .)
    GT              reduce using rule 24 (expr -> INTEGER .)
    GE              reduce using rule 24 (expr -> INTEGER .)
    EQUALS          reduce using rule 24 (expr -> INTEGER .)
    NE              reduce using rule 24 (expr -> INTEGER .)
    SEMI            reduce using rule 24 (expr -> INTEGER .)
    TO              reduce using rule 24 (expr -> INTEGER .)
    DO              reduce using rule 24 (expr -> INTEGER .)


state 52

    (25) expr -> FLOAT .

    PLUS            reduce using rule 25 (expr -> FLOAT .)
    MINUS           reduce using rule 25 (expr -> FLOAT .)
    TIMES           reduce using rule 25 (expr -> FLOAT .)
    DIVIDE          reduce using rule 25 (expr -> FLOAT .)
    POWER           reduce using rule 25 (expr -> FLOAT .)
    MOD             reduce using rule 25 (expr -> FLOAT .)
    RPAREN          reduce using rule 25 (expr -> FLOAT .)
    COMMA           reduce using rule 25 (expr -> FLOAT .)
    LT              reduce using rule 25 (expr -> FLOAT .)
    LE              reduce using rule 25 (expr -> FLOAT .)
    GT              reduce using rule 25 (expr -> FLOAT .)
    GE              reduce using rule 25 (expr -> FLOAT .)
    EQUALS          reduce using rule 25 (expr -> FLOAT .)
    NE              reduce using rule 25 (expr -> FLOAT .)
    SEMI            reduce using rule 25 (expr -> FLOAT .)
    TO              reduce using rule 25 (expr -> FLOAT .)
    DO              reduce using rule 25 (expr -> FLOAT .)


state 53

    (26) expr -> variable .

    PLUS            reduce using rule 26 (expr -> variable .)
    MINUS           reduce using rule 26 (expr -> variable .)
    TIMES           reduce using rule 26 (expr -> variable .)
    DIVIDE          reduce using rule 26 (expr -> variable .)
    POWER           reduce using rule 26 (expr -> variable .)
    MOD             reduce using rule 26 (expr -> variable .)
    RPAREN          reduce using rule 26 (expr -> variable .)
    COMMA           reduce using rule 26 (expr -> variable .)
    LT              reduce using rule 26 (expr -> variable .)
    LE              reduce using rule 26 (expr -> variable .)
    GT              reduce using rule 26 (expr -> variable .)
    GE              reduce using rule 26 (expr -> variable .)
    EQUALS          reduce using rule 26 (expr -> variable .)
    NE              reduce using rule 26 (expr -> variable .)
    SEMI            reduce using rule 26 (expr -> variable .)
    TO              reduce using rule 26 (expr -> variable .)
    DO              reduce using rule 26 (expr -> variable .)


state 54

    (13) command -> WRITE LPAREN wlist . RPAREN ending
    (51) wlist -> wlist . COMMA witem

    RPAREN          shift and go to state 75
    COMMA           shift and go to state 68


state 55

    (15) command -> WRITE LPAREN RPAREN . ending
    (36) ending -> . SEMI

    SEMI            shift and go to state 32

    ending                         shift and go to state 76

state 56

    (16) command -> PROGRAM variable ending .

    NEWLINE         reduce using rule 16 (command -> PROGRAM variable ending .)


state 57

    (19) command -> variable COLON variable . ending
    (36) ending -> . SEMI

    SEMI            shift and go to state 32

    ending                         shift and go to state 77

state 58

    (21) command -> variable COLON EQUALS . expr SEMI
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    variable                       shift and go to state 53
    expr                           shift and go to state 78

state 59

    (17) command -> VAR varlist COLON . variable ending
    (33) variable -> . ID

    ID              shift and go to state 21

    variable                       shift and go to state 79

state 60

    (22) varlist -> varlist COMMA . variable
    (33) variable -> . ID

    ID              shift and go to state 21

    variable                       shift and go to state 80

state 61

    (42) command -> END ending INTEGER . INTEGER

    INTEGER         shift and go to state 81


state 62

    (37) command -> IF LPAREN relexpr . RPAREN THEN INTEGER INTEGER
    (39) command -> IF LPAREN relexpr . RPAREN THEN error

    RPAREN          shift and go to state 82


state 63

    (38) command -> IF LPAREN error . RPAREN THEN INTEGER INTEGER

    RPAREN          shift and go to state 83


state 64

    (44) relexpr -> expr . LT expr
    (45) relexpr -> expr . LE expr
    (46) relexpr -> expr . GT expr
    (47) relexpr -> expr . GE expr
    (48) relexpr -> expr . EQUALS expr
    (49) relexpr -> expr . NE expr
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    LT              shift and go to state 84
    LE              shift and go to state 85
    GT              shift and go to state 86
    GE              shift and go to state 87
    EQUALS          shift and go to state 88
    NE              shift and go to state 89
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 65

    (50) command -> FOR variable COLON . EQUALS expr TO expr DO INTEGER INTEGER

    EQUALS          shift and go to state 90


state 66

    (55) numlist -> numlist COMMA number .

    COMMA           reduce using rule 55 (numlist -> numlist COMMA number .)
    NEWLINE         reduce using rule 55 (numlist -> numlist COMMA number .)


state 67

    (10) command -> WRITELN LPAREN wlist RPAREN . ending
    (36) ending -> . SEMI

    SEMI            shift and go to state 32

    ending                         shift and go to state 91

state 68

    (51) wlist -> wlist COMMA . witem
    (53) witem -> . STRING
    (54) witem -> . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    STRING          shift and go to state 49
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    witem                          shift and go to state 92
    expr                           shift and go to state 50
    variable                       shift and go to state 53

state 69

    (27) expr -> expr PLUS . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 93
    variable                       shift and go to state 53

state 70

    (28) expr -> expr MINUS . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 94
    variable                       shift and go to state 53

state 71

    (29) expr -> expr TIMES . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 95
    variable                       shift and go to state 53

state 72

    (30) expr -> expr DIVIDE . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 96
    variable                       shift and go to state 53

state 73

    (31) expr -> expr POWER . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 97
    variable                       shift and go to state 53

state 74

    (32) expr -> expr MOD . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 98
    variable                       shift and go to state 53

state 75

    (13) command -> WRITE LPAREN wlist RPAREN . ending
    (36) ending -> . SEMI

    SEMI            shift and go to state 32

    ending                         shift and go to state 99

state 76

    (15) command -> WRITE LPAREN RPAREN ending .

    NEWLINE         reduce using rule 15 (command -> WRITE LPAREN RPAREN ending .)


state 77

    (19) command -> variable COLON variable ending .

    NEWLINE         reduce using rule 19 (command -> variable COLON variable ending .)


state 78

    (21) command -> variable COLON EQUALS expr . SEMI
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    SEMI            shift and go to state 100
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 79

    (17) command -> VAR varlist COLON variable . ending
    (36) ending -> . SEMI

    SEMI            shift and go to state 32

    ending                         shift and go to state 101

state 80

    (22) varlist -> varlist COMMA variable .

    COLON           reduce using rule 22 (varlist -> varlist COMMA variable .)
    COMMA           reduce using rule 22 (varlist -> varlist COMMA variable .)


state 81

    (42) command -> END ending INTEGER INTEGER .

    NEWLINE         reduce using rule 42 (command -> END ending INTEGER INTEGER .)


state 82

    (37) command -> IF LPAREN relexpr RPAREN . THEN INTEGER INTEGER
    (39) command -> IF LPAREN relexpr RPAREN . THEN error

    THEN            shift and go to state 102


state 83

    (38) command -> IF LPAREN error RPAREN . THEN INTEGER INTEGER

    THEN            shift and go to state 103


state 84

    (44) relexpr -> expr LT . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 104
    variable                       shift and go to state 53

state 85

    (45) relexpr -> expr LE . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 105
    variable                       shift and go to state 53

state 86

    (46) relexpr -> expr GT . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 106
    variable                       shift and go to state 53

state 87

    (47) relexpr -> expr GE . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 107
    variable                       shift and go to state 53

state 88

    (48) relexpr -> expr EQUALS . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 108
    variable                       shift and go to state 53

state 89

    (49) relexpr -> expr NE . expr
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    expr                           shift and go to state 109
    variable                       shift and go to state 53

state 90

    (50) command -> FOR variable COLON EQUALS . expr TO expr DO INTEGER INTEGER
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    variable                       shift and go to state 53
    expr                           shift and go to state 110

state 91

    (10) command -> WRITELN LPAREN wlist RPAREN ending .

    NEWLINE         reduce using rule 10 (command -> WRITELN LPAREN wlist RPAREN ending .)


state 92

    (51) wlist -> wlist COMMA witem .

    RPAREN          reduce using rule 51 (wlist -> wlist COMMA witem .)
    COMMA           reduce using rule 51 (wlist -> wlist COMMA witem .)


state 93

    (27) expr -> expr PLUS expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    PLUS            reduce using rule 27 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 27 (expr -> expr PLUS expr .)
    MOD             reduce using rule 27 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 27 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 27 (expr -> expr PLUS expr .)
    LT              reduce using rule 27 (expr -> expr PLUS expr .)
    LE              reduce using rule 27 (expr -> expr PLUS expr .)
    GT              reduce using rule 27 (expr -> expr PLUS expr .)
    GE              reduce using rule 27 (expr -> expr PLUS expr .)
    EQUALS          reduce using rule 27 (expr -> expr PLUS expr .)
    NE              reduce using rule 27 (expr -> expr PLUS expr .)
    SEMI            reduce using rule 27 (expr -> expr PLUS expr .)
    TO              reduce using rule 27 (expr -> expr PLUS expr .)
    DO              reduce using rule 27 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73

  ! TIMES           [ reduce using rule 27 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 27 (expr -> expr PLUS expr .) ]
  ! POWER           [ reduce using rule 27 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 69 ]
  ! MINUS           [ shift and go to state 70 ]
  ! MOD             [ shift and go to state 74 ]


state 94

    (28) expr -> expr MINUS expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    PLUS            reduce using rule 28 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 28 (expr -> expr MINUS expr .)
    MOD             reduce using rule 28 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 28 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 28 (expr -> expr MINUS expr .)
    LT              reduce using rule 28 (expr -> expr MINUS expr .)
    LE              reduce using rule 28 (expr -> expr MINUS expr .)
    GT              reduce using rule 28 (expr -> expr MINUS expr .)
    GE              reduce using rule 28 (expr -> expr MINUS expr .)
    EQUALS          reduce using rule 28 (expr -> expr MINUS expr .)
    NE              reduce using rule 28 (expr -> expr MINUS expr .)
    SEMI            reduce using rule 28 (expr -> expr MINUS expr .)
    TO              reduce using rule 28 (expr -> expr MINUS expr .)
    DO              reduce using rule 28 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73

  ! TIMES           [ reduce using rule 28 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 28 (expr -> expr MINUS expr .) ]
  ! POWER           [ reduce using rule 28 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 69 ]
  ! MINUS           [ shift and go to state 70 ]
  ! MOD             [ shift and go to state 74 ]


state 95

    (29) expr -> expr TIMES expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    PLUS            reduce using rule 29 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 29 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 29 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 29 (expr -> expr TIMES expr .)
    MOD             reduce using rule 29 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 29 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 29 (expr -> expr TIMES expr .)
    LT              reduce using rule 29 (expr -> expr TIMES expr .)
    LE              reduce using rule 29 (expr -> expr TIMES expr .)
    GT              reduce using rule 29 (expr -> expr TIMES expr .)
    GE              reduce using rule 29 (expr -> expr TIMES expr .)
    EQUALS          reduce using rule 29 (expr -> expr TIMES expr .)
    NE              reduce using rule 29 (expr -> expr TIMES expr .)
    SEMI            reduce using rule 29 (expr -> expr TIMES expr .)
    TO              reduce using rule 29 (expr -> expr TIMES expr .)
    DO              reduce using rule 29 (expr -> expr TIMES expr .)
    POWER           shift and go to state 73

  ! POWER           [ reduce using rule 29 (expr -> expr TIMES expr .) ]
  ! PLUS            [ shift and go to state 69 ]
  ! MINUS           [ shift and go to state 70 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 72 ]
  ! MOD             [ shift and go to state 74 ]


state 96

    (30) expr -> expr DIVIDE expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    PLUS            reduce using rule 30 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 30 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 30 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 30 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 30 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 30 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 30 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 30 (expr -> expr DIVIDE expr .)
    LE              reduce using rule 30 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 30 (expr -> expr DIVIDE expr .)
    GE              reduce using rule 30 (expr -> expr DIVIDE expr .)
    EQUALS          reduce using rule 30 (expr -> expr DIVIDE expr .)
    NE              reduce using rule 30 (expr -> expr DIVIDE expr .)
    SEMI            reduce using rule 30 (expr -> expr DIVIDE expr .)
    TO              reduce using rule 30 (expr -> expr DIVIDE expr .)
    DO              reduce using rule 30 (expr -> expr DIVIDE expr .)
    POWER           shift and go to state 73

  ! POWER           [ reduce using rule 30 (expr -> expr DIVIDE expr .) ]
  ! PLUS            [ shift and go to state 69 ]
  ! MINUS           [ shift and go to state 70 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 72 ]
  ! MOD             [ shift and go to state 74 ]


state 97

    (31) expr -> expr POWER expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    PLUS            reduce using rule 31 (expr -> expr POWER expr .)
    MINUS           reduce using rule 31 (expr -> expr POWER expr .)
    TIMES           reduce using rule 31 (expr -> expr POWER expr .)
    DIVIDE          reduce using rule 31 (expr -> expr POWER expr .)
    POWER           reduce using rule 31 (expr -> expr POWER expr .)
    MOD             reduce using rule 31 (expr -> expr POWER expr .)
    RPAREN          reduce using rule 31 (expr -> expr POWER expr .)
    COMMA           reduce using rule 31 (expr -> expr POWER expr .)
    LT              reduce using rule 31 (expr -> expr POWER expr .)
    LE              reduce using rule 31 (expr -> expr POWER expr .)
    GT              reduce using rule 31 (expr -> expr POWER expr .)
    GE              reduce using rule 31 (expr -> expr POWER expr .)
    EQUALS          reduce using rule 31 (expr -> expr POWER expr .)
    NE              reduce using rule 31 (expr -> expr POWER expr .)
    SEMI            reduce using rule 31 (expr -> expr POWER expr .)
    TO              reduce using rule 31 (expr -> expr POWER expr .)
    DO              reduce using rule 31 (expr -> expr POWER expr .)

  ! PLUS            [ shift and go to state 69 ]
  ! MINUS           [ shift and go to state 70 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 72 ]
  ! POWER           [ shift and go to state 73 ]
  ! MOD             [ shift and go to state 74 ]


state 98

    (32) expr -> expr MOD expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    RPAREN          reduce using rule 32 (expr -> expr MOD expr .)
    COMMA           reduce using rule 32 (expr -> expr MOD expr .)
    LT              reduce using rule 32 (expr -> expr MOD expr .)
    LE              reduce using rule 32 (expr -> expr MOD expr .)
    GT              reduce using rule 32 (expr -> expr MOD expr .)
    GE              reduce using rule 32 (expr -> expr MOD expr .)
    EQUALS          reduce using rule 32 (expr -> expr MOD expr .)
    NE              reduce using rule 32 (expr -> expr MOD expr .)
    SEMI            reduce using rule 32 (expr -> expr MOD expr .)
    TO              reduce using rule 32 (expr -> expr MOD expr .)
    DO              reduce using rule 32 (expr -> expr MOD expr .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74

  ! PLUS            [ reduce using rule 32 (expr -> expr MOD expr .) ]
  ! MINUS           [ reduce using rule 32 (expr -> expr MOD expr .) ]
  ! TIMES           [ reduce using rule 32 (expr -> expr MOD expr .) ]
  ! DIVIDE          [ reduce using rule 32 (expr -> expr MOD expr .) ]
  ! POWER           [ reduce using rule 32 (expr -> expr MOD expr .) ]
  ! MOD             [ reduce using rule 32 (expr -> expr MOD expr .) ]


state 99

    (13) command -> WRITE LPAREN wlist RPAREN ending .

    NEWLINE         reduce using rule 13 (command -> WRITE LPAREN wlist RPAREN ending .)


state 100

    (21) command -> variable COLON EQUALS expr SEMI .

    NEWLINE         reduce using rule 21 (command -> variable COLON EQUALS expr SEMI .)


state 101

    (17) command -> VAR varlist COLON variable ending .

    NEWLINE         reduce using rule 17 (command -> VAR varlist COLON variable ending .)


state 102

    (37) command -> IF LPAREN relexpr RPAREN THEN . INTEGER INTEGER
    (39) command -> IF LPAREN relexpr RPAREN THEN . error

    INTEGER         shift and go to state 111
    error           shift and go to state 112


state 103

    (38) command -> IF LPAREN error RPAREN THEN . INTEGER INTEGER

    INTEGER         shift and go to state 113


state 104

    (44) relexpr -> expr LT expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    RPAREN          reduce using rule 44 (relexpr -> expr LT expr .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 105

    (45) relexpr -> expr LE expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    RPAREN          reduce using rule 45 (relexpr -> expr LE expr .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 106

    (46) relexpr -> expr GT expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    RPAREN          reduce using rule 46 (relexpr -> expr GT expr .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 107

    (47) relexpr -> expr GE expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    RPAREN          reduce using rule 47 (relexpr -> expr GE expr .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 108

    (48) relexpr -> expr EQUALS expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    RPAREN          reduce using rule 48 (relexpr -> expr EQUALS expr .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 109

    (49) relexpr -> expr NE expr .
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    RPAREN          reduce using rule 49 (relexpr -> expr NE expr .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 110

    (50) command -> FOR variable COLON EQUALS expr . TO expr DO INTEGER INTEGER
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    TO              shift and go to state 114
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 111

    (37) command -> IF LPAREN relexpr RPAREN THEN INTEGER . INTEGER

    INTEGER         shift and go to state 115


state 112

    (39) command -> IF LPAREN relexpr RPAREN THEN error .

    NEWLINE         reduce using rule 39 (command -> IF LPAREN relexpr RPAREN THEN error .)


state 113

    (38) command -> IF LPAREN error RPAREN THEN INTEGER . INTEGER

    INTEGER         shift and go to state 116


state 114

    (50) command -> FOR variable COLON EQUALS expr TO . expr DO INTEGER INTEGER
    (24) expr -> . INTEGER
    (25) expr -> . FLOAT
    (26) expr -> . variable
    (27) expr -> . expr PLUS expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr TIMES expr
    (30) expr -> . expr DIVIDE expr
    (31) expr -> . expr POWER expr
    (32) expr -> . expr MOD expr
    (33) variable -> . ID

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    ID              shift and go to state 21

    variable                       shift and go to state 53
    expr                           shift and go to state 117

state 115

    (37) command -> IF LPAREN relexpr RPAREN THEN INTEGER INTEGER .

    NEWLINE         reduce using rule 37 (command -> IF LPAREN relexpr RPAREN THEN INTEGER INTEGER .)


state 116

    (38) command -> IF LPAREN error RPAREN THEN INTEGER INTEGER .

    NEWLINE         reduce using rule 38 (command -> IF LPAREN error RPAREN THEN INTEGER INTEGER .)


state 117

    (50) command -> FOR variable COLON EQUALS expr TO expr . DO INTEGER INTEGER
    (27) expr -> expr . PLUS expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . TIMES expr
    (30) expr -> expr . DIVIDE expr
    (31) expr -> expr . POWER expr
    (32) expr -> expr . MOD expr

    DO              shift and go to state 118
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    POWER           shift and go to state 73
    MOD             shift and go to state 74


state 118

    (50) command -> FOR variable COLON EQUALS expr TO expr DO . INTEGER INTEGER

    INTEGER         shift and go to state 119


state 119

    (50) command -> FOR variable COLON EQUALS expr TO expr DO INTEGER . INTEGER

    INTEGER         shift and go to state 120


state 120

    (50) command -> FOR variable COLON EQUALS expr TO expr DO INTEGER INTEGER .

    NEWLINE         reduce using rule 50 (command -> FOR variable COLON EQUALS expr TO expr DO INTEGER INTEGER .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 98 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 98 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 98 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 98 resolved as shift
WARNING: shift/reduce conflict for POWER in state 98 resolved as shift
WARNING: shift/reduce conflict for MOD in state 98 resolved as shift
